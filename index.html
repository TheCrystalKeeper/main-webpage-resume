<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sriram Srivatsan CS184 Pages</title>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="styling.css">
    
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$']]
            }
        };
    </script>
</head>
<body>
        <header>
        <h1>My Sticky Header</h1>
        <nav>
            <ul>
                <li><a href="#section1">Section 1</a></li>
                <li><a href="#section2">Section 2</a></li>
                <li><a href="#section3">Section 3</a></li>
            </ul>
        </nav>
    </header>
    <div class="main-page-content">
        <h2>CS 184 Writeups</h2>
        <center>
            <h5>by Sriram Srivatsan (sriram.srivatsan (at) berkeley.edu) and Jaron Erba (jaronerba (at) berkeley.edu)</h5>
        </center>
        <br>
        <h3>Homework 1 - Rasterizer</h3>
        <p>Homework 1 description here.</p>
        <br><br><br>
        <h3>Homework 2 - Meshes</h3>
        <p>Homework 2 was all about geometric modeling. In Part I, we first started with drawing curves using control points using de Casteljau subdivision. Using this abstraction, we increased our dimensionality to surfaces in order to render full .bez files.</p>
        <p>Part II was all about meshes and mesh algorithms. First, we started off by implementing area-weighted vertex normals for Phong shading, making our teapots and other mesh structures look less square. We then implemented edge flipping and splitting which allowed us to modify our mesh in real time. Finally, we implemented upsampling of our mesh through loop subdivision by using our edge splitting and flipping abstractions.</p>
        <p>Overall, the project was more fun than challenging. Unfortunately, pointers were our main issue throughout Part II, since a single bad reassignment could percolate, and debugging would require us to remember each step precisely. Thankfully, we simplified this process by writing out the algorithm by hand before we even started coding, which gave us something to reference in case anything went wrong.</p>
        <br><br><br>
        <h3>Homework 3 - Pathtracer</h3>
        <p>Homework 3 was a delightful trip into the world of pathtracers and global illumination. In Part I, we started out by generating rays and writing the necessary intersections to render our first image that used the surface normals. Part II was perhaps the most interesting section of the project, since with an edit to how we organized the BVH tree (That is, using surface area instead of the median), we were able to radically speed up our code, which was cause for great excitement.</p>
        <p>Now, armed with our ability to quickly render scenes, we took on Part III. Most of the tasks could be implemented using formulas from the lecture slides, but this part turned out to be a little more than we bargained for, as it took us much longer than expected. We had trouble finding a bug within the section, which ended up making sense, since it wasnâ€™t in that task the whole time. A bug in the collisions in Part II had caused us all the issues in Part III. Lesson learned: Always check old code. Other than that, this section was quite interesting once we got it working, because we finally got to see the shadows on the bunny and the floor.</p>
        <p>Part IV produced some stunning images that surpassed our expectations. With only writing one other recursive function, we were able to expand the number of light bounces, creating the delightful, soft look of global illumination. We were also able to see exactly how increasing the number of light bounces affected the image.</p>
        <p>Part V was also pretty neat, since it enabled us to see how adaptive sampling actually rendered the image. We simply had to write a new function to count how many samples the est_radiance_global_illumination() function returned. It was nice to see a visual representation of what we already assumed to be true: The areas in more shadow take longer to converge, and the ones in light converge quicker.</p>
        <br><br><br>
        <h3>Homework 4 - Cloth Sim</h3>
        <p>The Clothsim project was all about simulating an almost physically accurate cloth mesh in real time. Unlike project 3 where our renders took multiple minutes to render a scene, this project was much faster and could even be simulated real time with high fps. We used OpenGL, along with GPU acceleration and GLSL to achieve this! First, we started by creating a mesh representation of a square cloth using the mass and springs method. We had three types of springs, structural which attached vertices to ones directly adjacent in the cardinal directions, shearing which allowed us to connect these vertices diagonally, and bending which connected vertices two away from each other cardinally, each serving the purpose of making our simulation more realistic. Then, we used numeric integration to simulate the movement of the cloth given external forces. In order to make the simulation possible real time, we had to settle for an approximate calculation that incorporated only the position, velocity, and acceleration of the vertices. Then, we implemented collisions between the cloth mesh and other objects such as spheres and planes. Finally, we allowed the cloth to collide with itself, allowing for a more realistic 'cloth falling on a plane' animation which included folding and flattening of the cloth as it fell. Finally, we used GLSL to create cool shaders like we did in previous projects. The shaders included diffuse shading, Blinn-Phong, texturing, mirror simulation, bump mapping, and displacement mapping. Overall, this project was very interesting to work on, having a lot of depth in the topic while still being easy to understand.</p>
    </div>
    
    <script>
        var links = document.body.getElementsByTagName("a");
        var a = window.location.href.indexOf(".io");
        var repo_name = window.location.href.substring(a + 3);
        for (var i = 0; i < links.length; i++) {
            var link = links[i];
            var actual_name = link.href.substring(link.href.indexOf(".io") + 4);
            link.href = repo_name + actual_name;
        }
    </script>
</body>
</html>
